# 停机问题

## 为什么要证明停机问题

根据 **_丘奇-图灵论题_**，图灵可计算函数与可计算函数是一样的，也即图灵机的计算能力囊括了任何算法系统的能力。因此，若有一个函数不是图灵可计算的，那么该函数即为不可计算函数。于是乎，停机问题便是一个与不可计算函数相关联的问题，对它的回答能帮助我们建立对问题可解性的认识。

## 停机问题的证明思路

所谓停机问题，即 **“能否设计一个程序，用于检测任意程序最终会停止运行还是会无限运行下去?”**。

下面我们定义一个A_program，其输入参数是需测试的程序本身和其输入，如果该程序最终停止运行，返回True；如果该程序最终无法停止运行，则返回False。

据此我们写出一段伪代码：
```
def A_program (code, code_input):

    if code (code_input) halts:

        return True

    else:

        return False
```
要证明停机问题的不可解性，也即找到这样的测试程序使得上面这段伪代码失效，从而以反证法的角度得证：
```

def code (code_input):

    if A_program (code, code_input) is False:

        return True

    else:

        loop forever
```
由此可以看出，这两段伪代码的逻辑是矛盾的:当A_program (code, code_input)是False时（也就是code会无限循环下去时），code (code_input)是返回True值的（也就是code最终会停止运行）。

于是，我们证明了，没有这样一个通用的算法存在，此算法在所有可能的输入参数下可以解决停机问题。

# 二进制补码

## 整数表示法

计算机以二进制的方式来存储整数，但怎样存储才能不重不漏且方便加减运算呢？在解决这个问题的过程中便产生了原码、反码以及补码的概念

## 原码（Sign-and-Magnitude）

顾名思义，原码表示中，既要表示符号，又要表示数值大小，因此把最高位作为符号位，正数取0负数取1。

如取码长N=8，**4**将表示为 **00000100**；**-4**则表示为 **10000100**

然而计算机并不采用原码表示法，原因有下:

- 不方便进行加减

- 有两个零：**+0**：**00000000**；**-0**：**10000000**

## 反码（One's complement）

宜将反码理解成一种映射：对于正整数，其像即为其原码；对于负整数-x(x>0)，其像即为2<sup>N</sup>-1-x。

如取码长N=8，**-127**即表示为 **10000000**

显然，计算机也不采用反码表示法，因为：

- 不方便加减（将进位（即1）加到结果里才能得到正确结果：\[-3+2\]确实等于\[-3\]+\[2\]，因为没有进位，但\[-2+3\]则不等于\[-2\]+\[3\]

- 同样有两个0：**+0**：**00000000**；**-0**：**11111111**

## 补码（Two's complement）

对于正整数，其像为其原码；对于负整数-x，其像为2\^N-x，**也即-x反码加1**！

如取码长N=8，**-25**表示为 **11100111**；二进制补码 **11101110**的十进制表示为 **-18**

显然，在补码表示法中仅存在一个 **0**：**00000000**！

计算机采用补码表示法可以准确地进行整数加减法运算：\[X+Y\]=\[X\]+\[Y\]

# 基于 IEEE 754浮点数格式的 16 bit 浮点数表示

**Excess-63**

| Sign |   Exp   |    Frac   |                             Value                             |
|------|---------|-----------|---------------------------------------------------------------|
| 0    | 0000000 | 0000 0000 | +0.0                                                          |
| 1    | 0000000 | 0000 0000 | -0.0                                                          |
| 0    | 0111111 | 0000 0000 | +1.0                                                          |
| 1    | 0111111 | 0000 0000 | -1.0                                                          |
| *    | 0000000 | 1111 1111 | +/-(1-2<sup>-8</sup>)&times;2<sup>-62</sup> (最大非规范化数） |
| *    | 0000000 | 0000 0001 | +/-2<sup>-8</sup>&times;2<sup>-62</sup>（最小非规范化数）     |
| *    | 0000001 | 0000 0000 | +/-2<sup>-62</sup>（最小规范化浮点数）                        |
| *    | 1111110 | 1111 1111 | +/-(2-2<sup>-8</sup>)&times;2<sup>63</sup>(最大规范化浮点数)                                                              |
| *    | 1111111 | 0000 0000 | +/-&infin;                                                    |
| *    | 1111111 | non zero  | NaN                                                           |


