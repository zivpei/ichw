# 停机问题

## 为什么要证明停机问题

根据 **_丘奇-图灵论题_**，图灵可计算函数与可计算函数是一样的，也即图灵机的计算能力囊括了任何算法系统的能力。因此，若有一个函数不是图灵可计算的，那么该函数即为不可计算函数。于是乎，停机问题便是一个与不可计算函数相关联的问题，对它的回答能帮助我们建立对问题可解性的认识。

## 停机问题的证明思路

所谓停机问题，即 **“能否设计一个程序，用于检测任意程序最终会停止运行还是会无限运行下去?”**。

下面我们定义一个A_program，其输入参数是需测试的程序本身和其输入，如果该程序最终停止运行，返回True；如果该程序最终无法停止运行，则返回False。

据此我们写出一段伪代码：
```
def A_program (code, code_input):

    if code (code_input) halts:

        return True

    else:

        return False
```
要证明停机问题的不可解性，也即找到这样的测试程序使得上面这段伪代码失效，从而以反证法的角度得证：
```

def code (code_input):

    if A_program (code, code_input) is False:

        return True

    else:

        loop forever
```
由此可以看出，这两段伪代码的逻辑是矛盾的:当A_program (code, code_input)是False时（也就是code会无限循环下去时），code (code_input)是返回True值的（也就是code最终会停止运行）。

于是，我们证明了，没有这样一个通用的算法存在，此算法在所有可能的输入参数下可以解决停机问题。

# 二进制补码

## 整数表示法

计算机以二进制的方式来存储整数，但怎样存储才能不重不漏且方便加减运算呢？在解决这个问题的过程中便产生了原码、反码以及补码的概念

## 原码（Sign-and-Magnitude）

顾名思义，原码表示中，既要表示符号，又要表示数值大小，因此把最高位作为符号位，正数取0负数取1。

如取码长N=8， **4**将表示为 **00000100**； **-4**则表示为 **10000100**

然而计算机并不采用原码表示法，原因有下:
-不方便进行加减
-有两个零： **+0**： **00000000**； **-0**： **10000000**

## 反码（One's complement）

宜将反码理解成一种映射：对于正整数，其像即为其原码；对于负整数-x(x>0)，其像即为(2^N-1-x)。

